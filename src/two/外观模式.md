# 外观模式(Facade)

在初步了解 `外观模式` 时，觉得它和 `代理模式`、`中介者模式` 比较像，所以比较疑惑，书对其功能的描述解答了一部分疑惑：
`外观模式的目的不是给子系统添加新的功能接口，而是负责 **组合现有的功能** 来实现客户端的需要`，从而达到减少子系统内的模块与外界(比如客户端)的交互，达到松耦合的目前。

其实有很大部分设计模式都是对 `面向接口编程` 的具体落地方案，只是针对的功能点不同。

而针对 代理模式、中介者模式 的针对点是什么，后文再表。


书中给出的例子个人认为不太好理解，举出自己认为合适了示例，组装一台车的步骤：

1. 制造车轮
2. 制造车架
3. 制造车玻璃
4. 制造车

在看到代码实现，你可能和我的想法一样，这不就是把客户端里的业务移动到 Facade 类中吗，这不是多此一举吗，一起来看一下书中对此的解释。

虽然在代码表现上只是将代码进行了搬移，但是在逻辑上却发生了翻天覆地的变化，此时 Facade 可以说变成了汽车制造流程的代言人，它把内部模块的操作对客户端进行了屏蔽，这也是说如何当汽车制造流程发生改变，客户端对此是毫无感知的，从而不会影响到客户端的逻辑，从而达到了解耦合的目的。

简单说一下和中介者模式的区别：

* 中介者模式用来封装多个对象之间的交互，多用在系统内部的多个模块；
* 外观模式的封装是单向的，从客户端去访问系统内部，没有系统内部去访问客户端的需求；

