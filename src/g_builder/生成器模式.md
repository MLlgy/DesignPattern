# 生成器模式(Builder)

顾名思义，属于创建型的模式。


## 定义

定义是抽象的：

> 将一个复杂对象的构建与它的表示进行分离，使得同样的构建过程可以创建不同的表示。


其实定义中所谓的 **表示** 即为实例对象的创建，所谓的 **构建** 即为对实例对象的配置。

## 场景

制作一份文件，文件分为头部、内容、尾部，每种文件的格式都不同，
依照类别制作 PdfFile 和 Html 文件。将该过程使用代码进行描述，具体查看代码。

1. 将文件的制作过程抽象出来，为接口 Builder；
2. 依据具体制作流程，创建 Pdf 文件生成器、Html 文件生成器；
3. 建立指导者，知道具体产品的创建 - Director
4. 客户端调用，制作指定文件；

可以看到生成器模式中，对于构建过程是固定的、一成不变的，所以可以将具体流程抽象出来，比如 Builder，
具体的配置过程交于不同的生成器，分离了构建算法和具体生成器的实现。

在代码中 Director 的操作十分简单，只是调用 Builder 的相应方法完成生成器的工作流程，
但是在实际开发中，Director 会承担比较复杂的算法，比如进行一系列的算法之后，得到一些数据，根据数据配置相应的生成器，进行接下来操作。



## 使用生成器模式创建大对象

其实在实际开发中，最常看到的是通过 **简化的生成器模式** 去创建复杂对象，

1. 只是去创建一个对象，没必要定义 Builder 接口，直接定义一个具体的生成器；
2. 创建一个复杂对象，那么这个对象肯定会有很多不同的配置和步骤，那么就不需要 Director 这个只能进行固定配置流程的角色的，所以可以将该角色的工作合并到 Client 中

具体实现查看源码。

继续简化，可以将 Builder 至于 Client 内部类，具体查看源码。

## 使用生成器模式的优点


1. 降低耦合度

将构建过程独立出来，降低具体产品与构建过程的耦合度，使构建算法得以复用。

2. 灵活

可以通过修改 Builder 来达到修改效果，而作为指导者的 Director 完全无感知。

## 思考

生成器模式的本质：分类构建算法和具体产品的构建。


